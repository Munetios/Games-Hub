<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Checkers - Munetios Games Hub</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://api.munetios.com/beautiful-css/beautiful.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Google+Sans+Flex:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined"
    />
    <style>
      body {
        font-family: "Google Sans Flex", system-ui, sans-serif;
        background: linear-gradient(135deg, #c94b4b 0%, #4b134f 100%);
        min-height: 100vh;
      }
      .checkers-board {
        display: grid;
        grid-template-columns: repeat(8, 70px);
        grid-template-rows: repeat(8, 70px);
        gap: 0;
        border: 4px solid #8b4513;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      }
      .square {
        width: 70px;
        height: 70px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
      }
      .square.light {
        background: #f0d9b5;
      }
      .square.dark {
        background: #8b4513;
      }
      .square.selected {
        box-shadow: inset 0 0 0 3px #ffff00;
      }
      .square.valid-move {
        background: rgba(0, 255, 0, 0.3);
        box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.5);
      }
      .piece {
        width: 55px;
        height: 55px;
        border-radius: 50%;
        border: 3px solid #000;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        transition: all 0.2s;
      }
      .piece.red {
        background: radial-gradient(circle at 30% 30%, #ff6b6b, #c92a2a);
      }
      .piece.black {
        background: radial-gradient(circle at 30% 30%, #495057, #212529);
      }
      .piece.king::after {
        content: "‚ôî";
        color: gold;
      }
      .piece:hover {
        transform: scale(1.1);
      }
      .toast {
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
      }
      @keyframes slideIn {
        from {
          transform: translateX(400px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      .toast.hiding {
        animation: slideOut 0.3s ease-in forwards;
      }
      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(400px);
          opacity: 0;
        }
      }
    </style>
  </head>
  <body class="flex items-center justify-center p-4">
    <div class="liquid-glass p-8 max-w-3xl">
      <div class="text-center mb-4">
        <h1 class="text-4xl font-bold text-white mb-4">üî¥‚ö´ Checkers</h1>
        <div class="flex justify-between text-white text-lg mb-4">
          <span>Turn: <span id="turn" class="font-bold">Red</span></span>
          <span id="status" class="font-bold">Playing</span>
          <span>Mode: <span id="mode" class="font-bold">2 Player</span></span>
        </div>
      </div>
      <div class="checkers-board" id="checkersBoard"></div>
      <div class="mt-6 text-center">
        <button
          id="newGame"
          class="bg-white/20 hover:bg-white/30 text-white font-bold py-2 px-6 rounded-lg transition mr-2"
        >
          <span class="material-symbols-outlined align-middle">refresh</span>
          New Game
        </button>
        <button
          id="aiToggle"
          class="bg-white/20 hover:bg-white/30 text-white font-bold py-2 px-6 rounded-lg transition"
        >
          <span class="material-symbols-outlined align-middle">smart_toy</span>
          Play vs AI
        </button>
      </div>
      <div class="mt-4 text-white text-sm text-center">
        <p>Click a piece to select, then click a valid square to move</p>
        <a
          href="index.html"
          class="text-white/80 hover:text-white underline mt-2 inline-block"
          >‚Üê Back to Hub</a
        >
      </div>
    </div>

    <script>
      const board = document.getElementById("checkersBoard");
      const turnDisplay = document.getElementById("turn");
      const statusDisplay = document.getElementById("status");
      const modeDisplay = document.getElementById("mode");

      let gameState = [];
      let currentTurn = "red";
      let selectedPiece = null;
      let aiMode = false;
      let mustJump = false;

      function showToast(message, duration = 3000) {
        const toast = document.createElement("div");
        toast.className = "toast";
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
          toast.classList.add("hiding");
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }

      function initGame() {
        gameState = Array(8)
          .fill()
          .map(() => Array(8).fill(null));

        // Red pieces (top)
        for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 8; col++) {
            if ((row + col) % 2 === 1) {
              gameState[row][col] = { color: "red", king: false };
            }
          }
        }

        // Black pieces (bottom)
        for (let row = 5; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            if ((row + col) % 2 === 1) {
              gameState[row][col] = { color: "black", king: false };
            }
          }
        }

        currentTurn = "red";
        selectedPiece = null;
        mustJump = false;
        renderBoard();
      }

      function renderBoard() {
        board.innerHTML = "";
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const square = document.createElement("div");
            square.className =
              "square " + ((row + col) % 2 === 0 ? "light" : "dark");
            square.dataset.row = row;
            square.dataset.col = col;

            if (
              selectedPiece &&
              selectedPiece.row === row &&
              selectedPiece.col === col
            ) {
              square.classList.add("selected");
            }

            const piece = gameState[row][col];
            if (piece) {
              const pieceDiv = document.createElement("div");
              pieceDiv.className = `piece ${piece.color}${
                piece.king ? " king" : ""
              }`;
              square.appendChild(pieceDiv);
            }

            square.addEventListener("click", () => handleSquareClick(row, col));
            board.appendChild(square);
          }
        }
        turnDisplay.textContent = currentTurn === "red" ? "Red" : "Black";
      }

      function handleSquareClick(row, col) {
        const piece = gameState[row][col];

        if (selectedPiece) {
          if (isValidMove(selectedPiece.row, selectedPiece.col, row, col)) {
            movePiece(selectedPiece.row, selectedPiece.col, row, col);
            selectedPiece = null;
          } else if (piece && piece.color === currentTurn) {
            selectedPiece = { row, col };
            renderBoard();
            highlightValidMoves(row, col);
          } else {
            selectedPiece = null;
            renderBoard();
          }
        } else if (piece && piece.color === currentTurn) {
          selectedPiece = { row, col };
          renderBoard();
          highlightValidMoves(row, col);
        }
      }

      function highlightValidMoves(fromRow, fromCol) {
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            if (isValidMove(fromRow, fromCol, row, col)) {
              const square = board.children[row * 8 + col];
              square.classList.add("valid-move");
            }
          }
        }
      }

      function isValidMove(fromRow, fromCol, toRow, toCol) {
        if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
        if (gameState[toRow][toCol]) return false;

        const piece = gameState[fromRow][fromCol];
        if (!piece) return false;

        const rowDiff = toRow - fromRow;
        const colDiff = Math.abs(toCol - fromCol);

        const jumps = getJumps(currentTurn);
        if (
          jumps.length > 0 &&
          !jumps.some(
            (j) =>
              j.from[0] === fromRow &&
              j.from[1] === fromCol &&
              j.to[0] === toRow &&
              j.to[1] === toCol
          )
        ) {
          return false;
        }

        // Regular move
        if (colDiff === 1 && Math.abs(rowDiff) === 1) {
          if (!piece.king) {
            if (piece.color === "red" && rowDiff > 0) return true;
            if (piece.color === "black" && rowDiff < 0) return true;
          } else {
            return true;
          }
        }

        // Jump move
        if (colDiff === 2 && Math.abs(rowDiff) === 2) {
          const midRow = (fromRow + toRow) / 2;
          const midCol = (fromCol + toCol) / 2;
          const midPiece = gameState[midRow][midCol];

          if (midPiece && midPiece.color !== piece.color) {
            if (!piece.king) {
              if (piece.color === "red" && rowDiff > 0) return true;
              if (piece.color === "black" && rowDiff < 0) return true;
            } else {
              return true;
            }
          }
        }

        return false;
      }

      function getJumps(color) {
        const jumps = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = gameState[row][col];
            if (piece && piece.color === color) {
              const directions = piece.king
                ? [
                    [2, 2],
                    [2, -2],
                    [-2, 2],
                    [-2, -2],
                  ]
                : color === "red"
                ? [
                    [2, 2],
                    [2, -2],
                  ]
                : [
                    [-2, 2],
                    [-2, -2],
                  ];

              for (const [dr, dc] of directions) {
                const toRow = row + dr;
                const toCol = col + dc;

                // Check if destination is valid without calling isValidMove (to avoid recursion)
                if (
                  toRow >= 0 &&
                  toRow <= 7 &&
                  toCol >= 0 &&
                  toCol <= 7 &&
                  !gameState[toRow][toCol]
                ) {
                  const midRow = row + dr / 2;
                  const midCol = col + dc / 2;
                  const midPiece = gameState[midRow][midCol];

                  // Check if there's an opponent piece to jump over
                  if (midPiece && midPiece.color !== color) {
                    jumps.push({ from: [row, col], to: [toRow, toCol] });
                  }
                }
              }
            }
          }
        }
        return jumps;
      }

      function movePiece(fromRow, fromCol, toRow, toCol) {
        const piece = gameState[fromRow][fromCol];
        gameState[toRow][toCol] = piece;
        gameState[fromRow][fromCol] = null;

        // Check for jump
        if (Math.abs(toRow - fromRow) === 2) {
          const midRow = (fromRow + toRow) / 2;
          const midCol = (fromCol + toCol) / 2;
          gameState[midRow][midCol] = null;
          showToast("üéØ Jump!", 1500);
        }

        // Check for king promotion
        if (
          (piece.color === "red" && toRow === 7) ||
          (piece.color === "black" && toRow === 0)
        ) {
          if (!piece.king) {
            piece.king = true;
            showToast("üëë King!", 2000);
          }
        }

        // Switch turns
        currentTurn = currentTurn === "red" ? "black" : "red";
        renderBoard();
        checkWinner();

        if (
          aiMode &&
          currentTurn === "black" &&
          statusDisplay.textContent === "Playing"
        ) {
          setTimeout(makeAIMove, 800);
        }
      }

      function makeAIMove() {
        const moves = getAllMoves("black");
        if (moves.length === 0) {
          statusDisplay.textContent = "Red Wins!";
          showToast("üéâ Red Wins!", 3000);
          return;
        }

        const jumps = moves.filter((m) => Math.abs(m.to[0] - m.from[0]) === 2);
        const move =
          jumps.length > 0
            ? jumps[Math.floor(Math.random() * jumps.length)]
            : moves[Math.floor(Math.random() * moves.length)];

        movePiece(move.from[0], move.from[1], move.to[0], move.to[1]);
      }

      function getAllMoves(color) {
        const moves = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = gameState[row][col];
            if (piece && piece.color === color) {
              for (let tr = 0; tr < 8; tr++) {
                for (let tc = 0; tc < 8; tc++) {
                  if (isValidMove(row, col, tr, tc)) {
                    moves.push({ from: [row, col], to: [tr, tc] });
                  }
                }
              }
            }
          }
        }
        return moves;
      }

      function checkWinner() {
        let redCount = 0,
          blackCount = 0;
        for (let row of gameState) {
          for (let piece of row) {
            if (piece) {
              if (piece.color === "red") redCount++;
              if (piece.color === "black") blackCount++;
            }
          }
        }

        if (redCount === 0) {
          statusDisplay.textContent = "Black Wins!";
          showToast("üéâ Black Wins!", 3000);
        } else if (blackCount === 0) {
          statusDisplay.textContent = "Red Wins!";
          showToast("üéâ Red Wins!", 3000);
        } else {
          statusDisplay.textContent = "Playing";
        }
      }

      document.getElementById("newGame").addEventListener("click", () => {
        initGame();
        showToast("üîÑ New Game Started", 1500);
      });

      document.getElementById("aiToggle").addEventListener("click", () => {
        aiMode = !aiMode;
        modeDisplay.textContent = aiMode ? "vs AI" : "2 Player";
        const btn = document.getElementById("aiToggle");
        if (aiMode) {
          btn.innerHTML =
            '<span class="material-symbols-outlined align-middle">person</span> Play vs Human';
          showToast("ü§ñ AI Mode Enabled", 2000);
          if (currentTurn === "black") {
            setTimeout(makeAIMove, 800);
          }
        } else {
          btn.innerHTML =
            '<span class="material-symbols-outlined align-middle">smart_toy</span> Play vs AI';
          showToast("üë• Two Player Mode", 2000);
        }
      });

      initGame();
    </script>
  </body>
</html>
