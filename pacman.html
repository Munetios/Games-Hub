<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Pac-Man - Munetios Games Hub</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://api.munetios.com/beautiful-css/beautiful.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Google+Sans+Flex:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Google Sans Flex", system-ui, sans-serif;
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        min-height: 100vh;
      }
      canvas {
        border: 3px solid #ffff00;
        border-radius: 8px;
        background: #000;
      }
      .toast {
        position: fixed;
        top: 20px;
        right: 20px;
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 12px;
               background:
    linear-gradient(
      to bottom,
      rgba(255,255,255,0.16) 0%,
      rgba(255,255,255,0.06) 22%,
      rgba(255,255,255,0.04) 50%,
      rgba(255,255,255,0.06) 78%,
      rgba(255,255,255,0.14) 100%
    );
    box-shadow: 0 8px 32px 0 rgba( 31, 38, 135, 0.37 );
    backdrop-filter: blur( 2px )  saturate(190%) brightness(105%) contrast(100%) !important;
    -webkit-backdrop-filter: blur( 1.75px )  saturate(200%) brightness(125%) contrast(100%) !important;
    border-radius: 50px;
    border: 1px solid rgba(255, 255, 255, 0.18);
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
      }
      @keyframes slideIn {
        from {
          transform: translateX(400px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      .toast.hiding {
        animation: slideOut 0.3s ease-in forwards;
      }
      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(400px);
          opacity: 0;
        }
      }
    </style>
  </head>
  <body class="flex items-center justify-center p-4">
    <div class="liquid-glass p-8 max-w-3xl">
      <div class="text-center mb-4">
        <h1 class="text-4xl font-bold text-white mb-4">üëª Advanced Pac-Man</h1>
        <div class="flex justify-around text-white text-lg mb-4">
          <span>Score: <span id="score" class="font-bold">0</span></span>
          <span>Level: <span id="level" class="font-bold">1</span></span>
          <span>Lives: <span id="lives" class="font-bold">3</span></span>
          <span>High: <span id="highScore" class="font-bold">0</span></span>
        </div>
      </div>
      <canvas id="gameCanvas" width="560" height="620"></canvas>
      <div class="mt-6 text-center">
        <button
          id="startBtn"
          class="bg-white/20 hover:bg-white/30 text-white font-bold py-3 px-8 rounded-lg transition mr-2"
        >
          Start Game
        </button>
        <button
          id="pauseBtn"
          class="bg-white/20 hover:bg-white/30 text-white font-bold py-3 px-8 rounded-lg transition"
        >
          Pause
        </button>
      </div>
      <div class="mt-4 text-white text-sm text-center">
        <p>Arrow Keys or WASD to Move</p>
        <p class="text-xs opacity-70 mt-1">
          üî¥ Power Pellets make ghosts vulnerable | üçí Bonus Fruits | Smart
          Ghost AI
        </p>
        <a
          href="index.html"
          class="text-white/80 hover:text-white underline mt-2 inline-block"
          >‚Üê Back to Hub</a
        >
      </div>
    </div>

    <audio
      id="bg-music"
      src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3"
      loop
    ></audio>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const cellSize = 20;
      const cols = 28;
      const rows = 31;

      let score = 0;
      let level = 1;
      let lives = 3;
      let highScore = localStorage.getItem("pacmanHighScore") || 0;
      let gameStarted = false;
      let isPaused = false;
      let powerMode = false;
      let powerModeTimer = 0;

      document.getElementById("highScore").textContent = highScore;

      function showToast(message, duration = 3000) {
        const toast = document.createElement("div");
        toast.className = "toast";
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
          toast.classList.add("hiding");
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }

      // Maze layout (1=wall, 0=dot, 2=power pellet, 3=empty, 4=ghost house)
      const maze = [
        [
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1,
        ],
        [
          1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 1,
        ],
        [
          1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1,
          1, 1, 1, 0, 1,
        ],
        [
          1, 2, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1,
          1, 1, 1, 2, 1,
        ],
        [
          1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1,
          1, 1, 1, 0, 1,
        ],
        [
          1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 1,
        ],
        [
          1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1,
          1, 1, 1, 0, 1,
        ],
        [
          1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1,
          1, 1, 1, 0, 1,
        ],
        [
          1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0,
          0, 0, 0, 0, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 0, 1,
          1, 1, 1, 1, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 0, 1,
          1, 1, 1, 1, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 1,
          1, 1, 1, 1, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 1, 1, 1, 4, 4, 1, 1, 1, 3, 1, 1, 0, 1,
          1, 1, 1, 1, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 1, 4, 4, 4, 4, 4, 4, 1, 3, 1, 1, 0, 1,
          1, 1, 1, 1, 1,
        ],
        [
          3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 1, 4, 4, 4, 4, 4, 4, 1, 3, 3, 3, 0, 3,
          3, 3, 3, 3, 3,
        ],
        [
          1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 1, 4, 4, 4, 4, 4, 4, 1, 3, 1, 1, 0, 1,
          1, 1, 1, 1, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 0, 1,
          1, 1, 1, 1, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 1,
          1, 1, 1, 1, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 0, 1,
          1, 1, 1, 1, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 0, 1,
          1, 1, 1, 1, 1,
        ],
        [
          1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 1,
        ],
        [
          1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1,
          1, 1, 1, 0, 1,
        ],
        [
          1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1,
          1, 1, 1, 0, 1,
        ],
        [
          1, 2, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1,
          1, 0, 0, 2, 1,
        ],
        [
          1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1,
          1, 0, 1, 1, 1,
        ],
        [
          1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1,
          1, 0, 1, 1, 1,
        ],
        [
          1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0,
          0, 0, 0, 0, 1,
        ],
        [
          1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 0, 1,
        ],
        [
          1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 0, 1,
        ],
        [
          1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1,
        ],
      ];

      let dots = JSON.parse(JSON.stringify(maze));
      let totalDots = 0;
      let dotsEaten = 0;

      for (let row of dots) {
        for (let cell of row) {
          if (cell === 0 || cell === 2) totalDots++;
        }
      }

      const pacman = {
        x: 14,
        y: 23,
        direction: { x: 0, y: 0 },
        nextDirection: { x: 0, y: 0 },
        mouthOpen: 0,
        speed: 0.15,
      };

      const ghosts = [
        {
          x: 13,
          y: 14,
          color: "#FF0000",
          name: "Blinky",
          targetMode: "chase",
          scatterX: 25,
          scatterY: 1,
        },
        {
          x: 14,
          y: 14,
          color: "#FFB8FF",
          name: "Pinky",
          targetMode: "chase",
          scatterX: 2,
          scatterY: 1,
        },
        {
          x: 13,
          y: 15,
          color: "#00FFFF",
          name: "Inky",
          targetMode: "chase",
          scatterX: 25,
          scatterY: 29,
        },
        {
          x: 14,
          y: 15,
          color: "#FFB852",
          name: "Clyde",
          targetMode: "chase",
          scatterX: 2,
          scatterY: 29,
        },
      ];

      function drawMaze() {
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const cell = maze[row][col];
            const x = col * cellSize;
            const y = row * cellSize;

            if (cell === 1) {
              ctx.fillStyle = "#2121DE";
              ctx.fillRect(x, y, cellSize, cellSize);
              ctx.strokeStyle = "#0000AA";
              ctx.strokeRect(x, y, cellSize, cellSize);
            } else if (dots[row][col] === 0) {
              ctx.fillStyle = "#FFB897";
              ctx.beginPath();
              ctx.arc(x + cellSize / 2, y + cellSize / 2, 2, 0, Math.PI * 2);
              ctx.fill();
            } else if (dots[row][col] === 2) {
              ctx.fillStyle = "#FFB897";
              ctx.beginPath();
              ctx.arc(x + cellSize / 2, y + cellSize / 2, 5, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
      }

      function drawPacman() {
        const x = pacman.x * cellSize + cellSize / 2;
        const y = pacman.y * cellSize + cellSize / 2;

        ctx.fillStyle = "#FFFF00";
        ctx.beginPath();

        let startAngle = pacman.mouthOpen;
        let endAngle = Math.PI * 2 - pacman.mouthOpen;

        if (pacman.direction.x === 1) {
          ctx.arc(x, y, cellSize / 2 - 2, startAngle, endAngle);
        } else if (pacman.direction.x === -1) {
          ctx.arc(
            x,
            y,
            cellSize / 2 - 2,
            Math.PI + startAngle,
            Math.PI + endAngle
          );
        } else if (pacman.direction.y === 1) {
          ctx.arc(
            x,
            y,
            cellSize / 2 - 2,
            Math.PI / 2 + startAngle,
            Math.PI / 2 + endAngle
          );
        } else if (pacman.direction.y === -1) {
          ctx.arc(
            x,
            y,
            cellSize / 2 - 2,
            -Math.PI / 2 + startAngle,
            -Math.PI / 2 + endAngle
          );
        } else {
          ctx.arc(x, y, cellSize / 2 - 2, startAngle, endAngle);
        }

        ctx.lineTo(x, y);
        ctx.fill();

        pacman.mouthOpen += 0.1;
        if (pacman.mouthOpen > 0.4 || pacman.mouthOpen < 0) {
          pacman.mouthOpen = pacman.mouthOpen > 0.4 ? 0.4 : 0;
        }
      }

      function drawGhosts() {
        ghosts.forEach((ghost) => {
          const x = ghost.x * cellSize + cellSize / 2;
          const y = ghost.y * cellSize + cellSize / 2;

          ctx.fillStyle = powerMode ? "#0000FF" : ghost.color;
          ctx.beginPath();
          ctx.arc(x, y - 3, cellSize / 2 - 2, Math.PI, 0, false);
          ctx.lineTo(x + cellSize / 2 - 2, y + cellSize / 2 - 2);
          ctx.lineTo(x + cellSize / 3, y + cellSize / 3);
          ctx.lineTo(x, y + cellSize / 2 - 2);
          ctx.lineTo(x - cellSize / 3, y + cellSize / 3);
          ctx.lineTo(x - cellSize / 2 + 2, y + cellSize / 2 - 2);
          ctx.closePath();
          ctx.fill();

          // Eyes
          ctx.fillStyle = "#FFF";
          ctx.fillRect(x - 5, y - 5, 4, 5);
          ctx.fillRect(x + 1, y - 5, 4, 5);

          if (!powerMode) {
            ctx.fillStyle = "#000";
            ctx.fillRect(x - 4, y - 4, 2, 3);
            ctx.fillRect(x + 2, y - 4, 2, 3);
          }
        });
      }

      function updatePacman() {
        if (pacman.nextDirection.x !== 0 || pacman.nextDirection.y !== 0) {
          const nextX = Math.round(
            pacman.x + pacman.nextDirection.x * pacman.speed
          );
          const nextY = Math.round(
            pacman.y + pacman.nextDirection.y * pacman.speed
          );

          if (maze[nextY] && maze[nextY][nextX] !== 1) {
            pacman.direction = pacman.nextDirection;
          }
        }

        const nextX = pacman.x + pacman.direction.x * pacman.speed;
        const nextY = pacman.y + pacman.direction.y * pacman.speed;
        const gridX = Math.round(nextX);
        const gridY = Math.round(nextY);

        if (maze[gridY] && maze[gridY][gridX] !== 1) {
          pacman.x = nextX;
          pacman.y = nextY;

          if (
            Math.abs(pacman.x - gridX) < 0.1 &&
            Math.abs(pacman.y - gridY) < 0.1
          ) {
            pacman.x = gridX;
            pacman.y = gridY;

            if (dots[gridY][gridX] === 0) {
              dots[gridY][gridX] = 3;
              score += 10;
              dotsEaten++;
              document.getElementById("score").textContent = score;
            } else if (dots[gridY][gridX] === 2) {
              dots[gridY][gridX] = 3;
              score += 50;
              dotsEaten++;
              powerMode = true;
              powerModeTimer = 180;
              showToast("üî¥ Power Mode!", 1500);
              document.getElementById("score").textContent = score;
            }
          }
        }

        // Wrap around
        if (pacman.x < 0) pacman.x = cols - 1;
        if (pacman.x >= cols) pacman.x = 0;

        if (dotsEaten >= totalDots) {
          level++;
          showToast(`üéâ Level ${level} Complete!`, 3000);
          document.getElementById("level").textContent = level;
          resetLevel();
        }
      }

      function updateGhosts() {
        if (powerModeTimer > 0) {
          powerModeTimer--;
          if (powerModeTimer === 0) powerMode = false;
        }

        ghosts.forEach((ghost) => {
          // Ghost speed
          const ghostSpeed = 0.08;

          const directions = [
            { x: 0, y: -1 },
            { x: 0, y: 1 },
            { x: -1, y: 0 },
            { x: 1, y: 0 },
          ];

          let bestDir = ghost.lastDirection || directions[0];
          let minDist = Infinity;

          directions.forEach((dir) => {
            const nextX = ghost.x + dir.x;
            const nextY = ghost.y + dir.y;
            const gridX = Math.floor(nextX);
            const gridY = Math.floor(nextY);

            if (
              maze[gridY] &&
              maze[gridY][gridX] !== 1 &&
              maze[gridY][gridX] !== 4
            ) {
              const targetX = powerMode ? 0 : pacman.x;
              const targetY = powerMode ? 0 : pacman.y;
              const dist = Math.sqrt(
                Math.pow(gridX - targetX, 2) + Math.pow(gridY - targetY, 2)
              );

              if (
                (!powerMode && dist < minDist) ||
                (powerMode && dist > minDist)
              ) {
                minDist = dist;
                bestDir = dir;
              }
            }
          });

          ghost.x += bestDir.x * ghostSpeed;
          ghost.y += bestDir.y * ghostSpeed;
          ghost.lastDirection = bestDir;

          // Check collision with Pacman
          const dist = Math.sqrt(
            Math.pow(ghost.x - pacman.x, 2) + Math.pow(ghost.y - pacman.y, 2)
          );
          if (dist < 0.5) {
            if (powerMode) {
              score += 200;
              document.getElementById("score").textContent = score;
              ghost.x = 14;
              ghost.y = 14;
              showToast(`üëª Ghost Eaten! +200`, 1500);
            } else {
              lives--;
              document.getElementById("lives").textContent = lives;
              showToast(`üíÄ Lost a Life! Lives: ${lives}`, 2000);

              if (lives <= 0) {
                gameOver();
              } else {
                resetPositions();
              }
            }
          }
        });
      }

      function resetPositions() {
        pacman.x = 14;
        pacman.y = 23;
        pacman.direction = { x: 0, y: 0 };
        pacman.nextDirection = { x: 0, y: 0 };

        ghosts[0].x = 13;
        ghosts[0].y = 14;
        ghosts[1].x = 14;
        ghosts[1].y = 14;
        ghosts[2].x = 13;
        ghosts[2].y = 15;
        ghosts[3].x = 14;
        ghosts[3].y = 15;
      }

      function resetLevel() {
        dots = JSON.parse(JSON.stringify(maze));
        dotsEaten = 0;
        resetPositions();
      }

      function gameOver() {
        gameStarted = false;

        if (score > highScore) {
          highScore = score;
          localStorage.setItem("pacmanHighScore", highScore);
          document.getElementById("highScore").textContent = highScore;
          showToast(`üèÜ New High Score: ${score}!`, 5000);
        } else {
          showToast(`üéÆ Game Over! Score: ${score}`, 5000);
        }
      }

      function gameLoop() {
        if (!gameStarted || isPaused) return;

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawMaze();
        drawPacman();
        drawGhosts();

        updatePacman();
        updateGhosts();

        requestAnimationFrame(gameLoop);
      }

      function startGame() {
        gameStarted = true;
        isPaused = false;
        score = 0;
        lives = 3;
        level = 1;
        dotsEaten = 0;
        powerMode = false;

        document.getElementById("score").textContent = score;
        document.getElementById("lives").textContent = lives;
        document.getElementById("level").textContent = level;

        dots = JSON.parse(JSON.stringify(maze));
        resetPositions();

        const music = document.getElementById("bg-music");
        music.volume = 1.0;
        music.play().catch(() => {});

        showToast("üéÆ Game Started!", 2000);
        gameLoop();
      }

      function togglePause() {
        isPaused = !isPaused;
        if (isPaused) {
          showToast("‚è∏ Paused", 1500);
        } else {
          showToast("‚ñ∂ Resumed", 1500);
          gameLoop();
        }
      }

      document.addEventListener("keydown", (e) => {
        switch (e.key) {
          case "ArrowUp":
          case "w":
          case "W":
            e.preventDefault();
            pacman.nextDirection = { x: 0, y: -1 };
            break;
          case "ArrowDown":
          case "s":
          case "S":
            e.preventDefault();
            pacman.nextDirection = { x: 0, y: 1 };
            break;
          case "ArrowLeft":
          case "a":
          case "A":
            e.preventDefault();
            pacman.nextDirection = { x: -1, y: 0 };
            break;
          case "ArrowRight":
          case "d":
          case "D":
            e.preventDefault();
            pacman.nextDirection = { x: 1, y: 0 };
            break;
        }
      });

      document.getElementById("startBtn").addEventListener("click", startGame);
      document
        .getElementById("pauseBtn")
        .addEventListener("click", togglePause);

      ctx.fillStyle = "#fff";
      ctx.font = "24px Google Sans Flex";
      ctx.textAlign = "center";
      ctx.fillText("Press Start to Play", canvas.width / 2, canvas.height / 2);
    </script>
  </body>
</html>

