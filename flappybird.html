<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Flappy Bird - Munetios Games Hub</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Beautiful CSS -->
    <link
      rel="stylesheet"
      href="https://api.munetios.com/beautiful-css/beautiful.css"
    />
    <!-- Google Sans Flex font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Google+Sans+Flex:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Google Sans Flex", Arial, sans-serif;
        background: #181c20;
        margin: 0;
        padding: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: white;
        justify-content: flex-start;
      }
      .liquid-glass {
        margin-top: 32px;
        padding: 32px;
        max-width: 920px;
        width: 100%;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #game-canvas {
        background: linear-gradient(#87ceeb 70%, #e0f7fa 100%);
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        display: block;
        margin: 0 auto 16px auto;
      }
      .controls,
      .cheats {
        margin: 16px 0 0 0;
        width: 100%;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .cheats-options {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 8px;
      }
      .hidden {
        display: none;
      }
      .score {
        font-size: 1.5rem;

        margin: 12px 0;
        color: #ffffff;
        text-shadow: 0 2px 8px #fff8;
      }
      .level-label {
        font-weight: bold;
        margin-right: 8px;
        color: white;
      }
      .btn {
        font-family: "Google Sans Flex", Arial, sans-serif;
        font-size: 1rem;
        padding: 8px 18px;
        border-radius: 8px;
        border: none;
        background: #6300d4;
        color: #fff;
        cursor: pointer;
        transition: background 0.2s;
      }
      .btn:hover {
        background: #410777;
      }
      .cheats-toggle {
        display: flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        user-select: none;
      }
      .cheats-options label {
        font-size: 0.98rem;
        color: #ffffff;
      }
    </style>
  </head>
  <body>
    <div class="liquid-glass">
      <h1
        style="
          font-family: 'Google Sans Flex', Arial, sans-serif;
          text-align: center;
        "
      >
        Flappy Bird
      </h1>
      <div class="controls">
        <div>
          <span class="level-label">Level:</span>
          <select id="level-select" class="btn">
            <option value="super-easy">Super Easy</option>
            <option value="easy">Easy</option>
            <option value="normal" selected>Normal</option>
            <option value="hard">Hard</option>
            <option value="super-hard">Super Hard</option>
          </select>
        </div>
        <button id="restart-btn" class="btn">Restart</button>
      </div>
      <div class="cheats">
        <span class="cheats-toggle" id="cheats-toggle">
          <input type="checkbox" id="cheats-checkbox" />
          <label for="cheats-checkbox">Cheats</label>
        </span>
      </div>
      <div class="cheats-options hidden" id="cheats-options">
        <label>
          <input type="checkbox" id="never-lose" />
          Never lose
        </label>
        <label>
          <input type="checkbox" id="pass-through-walls" />
          Pass through walls
        </label>
      </div>
      <div class="score" id="score">Score: 0</div>
      <canvas id="game-canvas" width="800" height="540"></canvas>
    </div>

    <!-- Tone.js for sound effects -->
    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.min.js"></script>
    <!-- Background music (autoplay) -->
    <audio
      id="bg-music"
      src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3"
      loop
    ></audio>
    <script>
      // Autoplay background music with user gesture fallback
      const bgMusic = document.getElementById("bg-music");
      function tryPlayMusic() {
        bgMusic.volume = 1;
        bgMusic.play().catch(() => {
          // Wait for user gesture
          document.body.addEventListener(
            "pointerdown",
            () => {
              bgMusic.play();
            },
            { once: true }
          );
        });
      }
      window.addEventListener("DOMContentLoaded", tryPlayMusic);
    </script>
    <script>
      // Game constants
      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");
      const gravity = 0.18; // higher = faster falling   lower = slower falling
      const jumpStrength = -4.5; // lower = higher jump  higher = lower jump
      const birdSize = 36; // higher = bigger bird, lower = smaller bird
      const pipeWidth = 60; // higher = wider pipes, lower = narrower pipes
      const pipeGapEasy = 270; // higher = bigger gap, lower = smaller gap
      const pipeGapNormal = 100; // higher = bigger gap, lower = smaller gap
      const pipeGapHard = 80; // higher = bigger gap, lower = smaller gap
      const pipeGapSuperEasy = 450; // higher = bigger gap, lower = smaller gap
      const pipeGapSuperHard = 60; // higher = bigger gap, lower = smaller gap
      const pipeSpeedEasy = 2.0; // higher = faster pipes, lower = slower pipes
      const pipeSpeedNormal = 2.6; // higher = faster pipes, lower = slower pipes
      const pipeSpeedHard = 3.2; // higher = faster pipes, lower = slower pipes
      const pipeSpeedSuperEasy = 9.5; // higher = faster pipes, lower = slower pipes
      const pipeSpeedSuperHard = 4.0; // higher = faster pipes, lower = slower pipes
      const pipeInterval = 1000; // ms // higher = slower spawn rate, lower = faster spawn rate
      const pipeIntervalSuperEasy = 50; // ms for super-easy
      const bombRadius = 22; // higher = bigger bomb, lower = smaller bomb
      const bombIntervalSuperHard = 1400; // ms
      const bombSpeedSuperHard = 3.8;

      // Game state
      let pipes = []; // array of pipe objects
      let bombs = []; // array of bomb objects
      let bird = { x: 80, y: 240, vy: 0 }; // bird object with position and velocity
      let score = 0; // current score
      let highScore = 0; // highest score achieved
      let running = false; // is the game currently running
      let lastPipeTime = 0; // timestamp of the last pipe spawn
      let lastBombTime = 0; // timestamp of the last bomb spawn
      let level = "normal"; // current game difficulty level
      let neverLose = false; // cheat: never lose
      let passThroughWalls = false; // cheat: pass through walls
      let gameOver = false; // is the game over
      let animationFrameId = null; // ID of the current animation frame

      // DOM elements
      const scoreEl = document.getElementById("score");
      const restartBtn = document.getElementById("restart-btn");
      const levelSelect = document.getElementById("level-select");
      const cheatsToggle = document.getElementById("cheats-toggle");
      const cheatsCheckbox = document.getElementById("cheats-checkbox");
      const cheatsOptions = document.getElementById("cheats-options");
      const neverLoseCheckbox = document.getElementById("never-lose");
      const passThroughWallsCheckbox =
        document.getElementById("pass-through-walls");
      const titleEl = document.querySelector("h1");

      // Tone.js sound effects
      const jumpSynth = new Tone.Synth({
        oscillator: { type: "triangle" },
        envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 },
      }).toDestination();
      const pointSynth = new Tone.MembraneSynth().toDestination();
      const hitSynth = new Tone.MetalSynth({
        frequency: 120,
        envelope: { attack: 0.001, decay: 0.2, release: 0.2 },
        harmonicity: 5.1,
        modulationIndex: 32,
      }).toDestination();
      const bombSynth = new Tone.MetalSynth({
        frequency: 200,
        envelope: { attack: 0.001, decay: 0.1, release: 0.1 },
        harmonicity: 10,
        modulationIndex: 50,
      }).toDestination();

      function playJump() {
        jumpSynth.triggerAttackRelease("C5", "8n", Tone.now());
      }
      function playPoint() {
        pointSynth.triggerAttackRelease("C2", "8n", Tone.now());
      }
      function playHit() {
        hitSynth.triggerAttackRelease("C4", "16n", Tone.now());
      }
      function playBomb() {
        bombSynth.triggerAttackRelease("C3", "16n", Tone.now());
      }

      // Level settings
      function getLevelSettings() {
        if (level === "easy")
          return {
            gap: pipeGapEasy,
            speed: pipeSpeedEasy,
            pipeColor: "#4caf50",
            interval: pipeInterval,
          };
        if (level === "hard")
          return {
            gap: pipeGapHard,
            speed: pipeSpeedHard,
            pipeColor: "#4caf50",
            interval: pipeInterval,
          };
        if (level === "super-easy")
          return {
            gap: pipeGapSuperEasy,
            speed: pipeSpeedSuperEasy,
            pipeColor: "#4caf50",
            interval: pipeIntervalSuperEasy,
          };
        if (level === "super-hard")
          return {
            gap: pipeGapSuperHard,
            speed: pipeSpeedSuperHard,
            pipeColor: "#e53935",
            interval: pipeInterval,
          }; // Red pipes
        return {
          gap: pipeGapNormal,
          speed: pipeSpeedNormal,
          pipeColor: "#4caf50",
          interval: pipeInterval,
        };
      }

      // Game logic
      function resetGame() {
        // Cancel any previous animation frame to prevent multiple loops
        if (animationFrameId !== null) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        bird = { x: 80, y: 240, vy: 0 };
        pipes = [];
        bombs = [];
        score = 0;
        lastPipeTime = performance.now();
        lastBombTime = performance.now();
        running = true;
        gameOver = false;
        scoreEl.textContent = "Score: 0";
        // Reset cheats to current checkbox state
        neverLose = neverLoseCheckbox.checked;
        passThroughWalls = passThroughWallsCheckbox.checked;
        // Title color for super hard
        if (level === "super-hard") {
          titleEl.style.color = "#e53935";
          titleEl.style.textShadow = "0 0 16px #ff1744, 0 2px 8px #fff8";
        } else {
          titleEl.style.color = "";
          titleEl.style.textShadow = "";
        }
        animationFrameId = window.requestAnimationFrame(gameLoop);
      }

      function spawnPipe() {
        const { gap } = getLevelSettings();
        const minY = 60;
        const maxY = canvas.height - gap - 60;

        // For easy/normal: 40% chance of centered gap, 30% chance of narrow pipe
        let topY;
        let width = pipeWidth;

        if (level === "easy" || level === "normal") {
          // 40% chance for centered gap (easier to stay in middle)
          if (Math.random() < 0.4) {
            topY = (canvas.height - gap) / 2;
          } else {
            topY = Math.floor(Math.random() * (maxY - minY + 1)) + minY;
          }
          // 30% chance for narrower pipe (easier to pass through)
          if (Math.random() < 0.3) {
            width = Math.floor(pipeWidth * 0.5); // Half width
          }
        } else {
          topY = Math.floor(Math.random() * (maxY - minY + 1)) + minY;
        }

        // For super-hard, pipes move up/down
        let pipe = {
          x: canvas.width,
          top: topY,
          gap: gap,
          width: width,
          passed: false,
        };
        if (level === "super-hard") {
          pipe.vy =
            (Math.random() > 0.5 ? 1 : -1) * (1.2 + Math.random() * 1.2);
        }
        pipes.push(pipe);
      }

      function spawnBomb() {
        // Only in super-hard
        if (level !== "super-hard") return;
        // Bomb appears at random y, moves left
        const y =
          Math.floor(Math.random() * (canvas.height - 2 * bombRadius - 18)) +
          bombRadius;
        bombs.push({
          x: canvas.width + 20,
          y: y,
          vy: (Math.random() - 0.5) * 2.5, // slight vertical movement
        });
      }

      function update(dt) {
        if (!running) return;
        // Bird physics
        bird.vy += gravity;
        bird.y += bird.vy;

        // Pipes
        const { speed } = getLevelSettings();
        for (let pipe of pipes) {
          pipe.x -= speed;
          // Super-hard: pipes move up/down
          if (level === "super-hard" && pipe.vy) {
            pipe.top += pipe.vy;
            // Bounce off bounds
            if (pipe.top < 40 || pipe.top > canvas.height - pipe.gap - 40) {
              pipe.vy *= -1;
            }
          }
        }
        // Remove off-screen pipes
        pipes = pipes.filter((pipe) => pipe.x + pipe.width > 0);

        // Spawn pipes
        const { interval } = getLevelSettings();
        if (performance.now() - lastPipeTime > interval) {
          spawnPipe();
          lastPipeTime = performance.now();
        }

        // Bombs (super-hard only)
        if (level === "super-hard") {
          // Spawn bombs
          if (performance.now() - lastBombTime > bombIntervalSuperHard) {
            spawnBomb();
            lastBombTime = performance.now();
          }
          // Move bombs
          for (let bomb of bombs) {
            bomb.x -= bombSpeedSuperHard;
            bomb.y += bomb.vy;
            // Bounce off top/bottom
            if (bomb.y < bombRadius) {
              bomb.y = bombRadius;
              bomb.vy *= -1;
            }
            if (bomb.y > canvas.height - bombRadius - 18) {
              bomb.y = canvas.height - bombRadius - 18;
              bomb.vy *= -1;
            }
          }
          // Remove off-screen bombs
          bombs = bombs.filter((bomb) => bomb.x + bombRadius > 0);
        } else {
          bombs = [];
        }

        // Collision detection
        let collided = false;
        let bombHit = false;
        let pipeHit = false;
        for (let pipe of pipes) {
          // Pass through walls cheat
          if (passThroughWalls) continue;
          // Top pipe
          if (
            bird.x + birdSize > pipe.x &&
            bird.x < pipe.x + pipe.width &&
            (bird.y < pipe.top || bird.y + birdSize > pipe.top + pipe.gap)
          ) {
            collided = true;
            if (level === "super-hard") {
              pipeHit = true;
            }
          }
        }
        // Floor/ceiling collision
        if (!neverLose && !passThroughWalls) {
          if (bird.y < 0 || bird.y + birdSize > canvas.height) {
            collided = true;
          }
        }
        // Bomb collision (super-hard)
        if (level === "super-hard" && !neverLose && !passThroughWalls) {
          for (let bomb of bombs) {
            let dx = bird.x + birdSize / 2 - bomb.x;
            let dy = bird.y + birdSize / 2 - bomb.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < birdSize / 2 + bombRadius - 2) {
              collided = true;
              bombHit = true;
              break;
            }
          }
        }
        // For super-hard: only game over if hit a bomb or red pipe
        if (level === "super-hard" && (bombHit || pipeHit) && !neverLose) {
          if (bombHit) playBomb();
          if (pipeHit) playHit();
          running = false;
          gameOver = true;
          setTimeout(() => {
            scoreEl.textContent = `Game Over! Score: ${score}`;
          }, 100);
        } else if (collided && !neverLose && level !== "super-hard") {
          playHit();
          running = false;
          gameOver = true;
          setTimeout(() => {
            scoreEl.textContent = `Game Over! Score: ${score}`;
          }, 100);
        }

        // Score
        for (let pipe of pipes) {
          if (!pipe.passed && pipe.x + pipe.width < bird.x) {
            pipe.passed = true;
            score++;
            playPoint();
            scoreEl.textContent = `Score: ${score}`;
          }
        }
      }

      function draw() {
        // Clear
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw pipes
        ctx.save();
        const { pipeColor } = getLevelSettings();
        for (let pipe of pipes) {
          // Top pipe
          ctx.fillStyle = pipeColor;
          ctx.fillRect(pipe.x, 0, pipe.width, pipe.top);
          ctx.strokeStyle = level === "super-hard" ? "#b71c1c" : "#388e3c";
          ctx.lineWidth = 3;
          ctx.strokeRect(pipe.x, 0, pipe.width, pipe.top);

          // Bottom pipe
          ctx.fillStyle = pipeColor;
          ctx.fillRect(
            pipe.x,
            pipe.top + pipe.gap,
            pipe.width,
            canvas.height - pipe.top - pipe.gap
          );
          ctx.strokeStyle = level === "super-hard" ? "#b71c1c" : "#388e3c";
          ctx.strokeRect(
            pipe.x,
            pipe.top + pipe.gap,
            pipe.width,
            canvas.height - pipe.top - pipe.gap
          );
        }
        ctx.restore();

        // Draw bombs (super-hard)
        if (level === "super-hard") {
          ctx.save();
          for (let bomb of bombs) {
            // Bomb body
            ctx.beginPath();
            ctx.arc(bomb.x, bomb.y, bombRadius, 0, 2 * Math.PI);
            ctx.fillStyle = "#d50000";
            ctx.shadowColor = "#ff1744";
            ctx.shadowBlur = 12;
            ctx.fill();
            ctx.shadowBlur = 0;
            // Bomb fuse
            ctx.beginPath();
            ctx.moveTo(bomb.x, bomb.y - bombRadius);
            ctx.lineTo(bomb.x, bomb.y - bombRadius - 12);
            ctx.strokeStyle = "#fffde7";
            ctx.lineWidth = 3;
            ctx.stroke();
            // Bomb spark
            ctx.beginPath();
            ctx.arc(bomb.x, bomb.y - bombRadius - 14, 3, 0, 2 * Math.PI);
            ctx.fillStyle = "#ffd600";
            ctx.fill();
          }
          ctx.restore();
        }

        // Draw bird
        ctx.save();
        ctx.translate(bird.x + birdSize / 2, bird.y + birdSize / 2);
        ctx.rotate(Math.min(Math.PI / 4, bird.vy / 12));
        ctx.beginPath();
        ctx.arc(0, 0, birdSize / 2, 0, 2 * Math.PI);
        ctx.fillStyle = "#ffeb3b";
        ctx.shadowColor = "#fffde7";
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;
        // Eye
        ctx.beginPath();
        ctx.arc(birdSize / 6, -birdSize / 8, birdSize / 8, 0, 2 * Math.PI);
        ctx.fillStyle = "#222";
        ctx.fill();
        // Beak
        ctx.beginPath();
        ctx.moveTo(birdSize / 2, 0);
        ctx.lineTo(birdSize / 2 + 10, -5);
        ctx.lineTo(birdSize / 2 + 10, 5);
        ctx.closePath();
        ctx.fillStyle = "#ff9800";
        ctx.fill();
        ctx.restore();

        // Draw ground
        ctx.save();
        ctx.fillStyle = "#795548";
        ctx.fillRect(0, canvas.height - 18, canvas.width, 18);
        ctx.restore();
      }

      function gameLoop() {
        if (!running) return;
        update();
        draw();
        if (running) {
          animationFrameId = window.requestAnimationFrame(gameLoop);
        }
      }

      // Controls
      function jump() {
        if (!running) {
          if (gameOver) resetGame();
          return;
        }
        bird.vy = jumpStrength;
        playJump();
      }
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" || e.code === "ArrowUp") {
          e.preventDefault();
          jump();
        }
      });
      canvas.addEventListener("pointerdown", jump);

      restartBtn.addEventListener("click", resetGame);

      levelSelect.addEventListener("change", (e) => {
        level = e.target.value;
        resetGame();
      });

      // Cheats UI
      cheatsToggle.addEventListener("click", () => {
        cheatsCheckbox.checked = !cheatsCheckbox.checked;
        cheatsOptions.classList.toggle("hidden", !cheatsCheckbox.checked);
      });
      cheatsCheckbox.addEventListener("change", () => {
        cheatsOptions.classList.toggle("hidden", !cheatsCheckbox.checked);
      });
      neverLoseCheckbox.addEventListener("change", () => {
        neverLose = neverLoseCheckbox.checked;
      });
      passThroughWallsCheckbox.addEventListener("change", () => {
        passThroughWalls = passThroughWallsCheckbox.checked;
      });

      // Start game
      resetGame();
    </script>
  </body>
</html>
